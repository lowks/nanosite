title: template language

In site generation, `.md+`, `.html+`, `.xml+` and `.tmpl` files are run through the template engine. The template engine operates on template expressions, which are surrounded by double curly braces `\{{` `\}}`. Each template is compiled against a *context*, which is a set of variables available to the template.

Call the current context `context`. `context["key"]` denotes fetching the value of variable `key` from context `context`.

- [fetch](#fetch)
    - [basic fetch](#basic-fetch)
    - [macro call](#macro-call)
- [control blocks](#control-blocks)
    - [\#if](#if)

# <a name="fetch"></a> fetch

## <a name="basic-fetch"></a> basic fetch
**Syntax:**

    \{{ key \}}
	
**Semantics:** Evaluates to `context["key"]`. Can also grab nested entries with dot syntax: `\{{ site.url \}}` evaluates to `context["site"]["url"]`. By default, HTML is escaped. Use triple braces to grab variables containing HTML: `\{{{ linkToMyInstagram \}}}`

**Examples:**

- `\{{ title \}}` &rarr; `{{ title }}`
- `\{{ site.url \}}` &rarr; `{{ site.url }}`

## <a name="macro-call"></a> macro call
**Syntax:**

    \{{ key [parameter1 ... parameterN] \}}
	
**Semantics:** If `context["key"]` is a macro, then call it with parameters `context`, `parameter1`, ... `parameterN`.

**Examples:**

- `\{{ formatDate date \}}` &rarr; `{{ formatDate date }}`

# <a name="control-blocks"></a> control blocks

## <a name="if"></a> #if
**Syntax:**

    \{{ #if key \}}
	  [A]
	[\{{ #elif key2 \}}]
	  [B]
	  ...
	[\{{ #else \}}]
	  [C]
	\{{ #endif \}}
	
**Semantics:** If `context["key"]` evaluates to `True`, then evaluate code block `[A]`. Otherwise, if `context["key2"]` evaluates to `True`, then evaluate block `[B]`. ... If none of the conditions are met, evaluate block `[C]`. `#elif` and `#else` clauses are optional.

**Examples:**

- `\{{ #if title \}}\{{ title \}}\{{ #endif \}}` &rarr; `{{ title }}`

  - \\{{key [param1 param2 .. paramN]\\}}: if ctx["key"] is a function, then it will be called with parameters [ctx], [param1], .. [paramN].
    - Supported types: int, string, float, identifier. For identifiers, grab their corresponding object. Ex: \\{{macro foo\\}} will call [macro] with parameter ctx["foo"].
- \\{{ #for x in key \\}}: if ctx["key"] is a collection, loop through its items
  - [key] can span spaces, allowing for macro calls: "newest 5 posts" calls macro [newest] with parameters 5, ctx["posts"]
- \\{{#endfor\\}}: end of for loop
- \\{{#if key\\}}: execute block if ctx["key"] evaluates to True
- \\{{#elif key\\}}: execute block if ctx["key"] evaluates to True and previous if/elifs evaluated to false
- \\{{#else\\}}: execute block if all previous if/elifs evaluated to false
- \\{{#endif\\}}: end of if block
- \\{{#macro name [param1 param2 .. paramN]\\}}: begins a macro block. ctx[name] becomes a function that fills in the contents of the macro block using the given parameters as additional context variables, and returns the result (like a template)
  - Macros cannot be nested inside of any other block
  - Within a file, macros must be declared before they are used
- \\{{#endmacro\\}}: end of macro block
- \\{{#define name value\\}}: sets ctx[name] to [value] where value is a literal (int, string, float) or identifier.
  - As with #for, [value] can span spaces, allowing for macro calls

- Keys can be nested with dot notation, e.g. if ctx = {"key": {"a": 3\\}}, then "key.a" will fetch the value 3 (this works for dictionary entries as well as object attributes)
- Delimiters can be escaped with a backlash, and the template compiler will ignore them. In the site generator, \\\\{{ will output \\{{, and \\\\}} will output \\}}
