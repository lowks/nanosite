nanosite: static site generator

Template language (given context ctx).
- {{key}}: replaced with ctx["key"], HTML characters escaped
  - {{key [param1 param2 .. paramN]}}: if ctx["key"] is a function, then it will be called with parameters [ctx], [param1], .. [paramN]. Parsing tries to figure out the appropriate type (supported: string, int, float). Use quotes ('"') around a parameter for strings with spaces.
- {{{key}}}: replaced with ctx["key"], no escape (i.e. for HTML insertion)
- {{#for x in key}}: if ctx["key"] is a collection, loop through its items
- {{#endfor}}: end of for loop
- {{#if key}}: execute block if ctx["key"] evaluates to True
- {{#elif key}}: execute block if ctx["key"] evaluates to True and previous if/elifs evaluated to false
- {{#else}}: execute block if all previous if/elifs evaluated to false
- {{#endif}}: end of if block

- Keys can be nested with dot notation, e.g. if ctx = {"key": {"a": 3}}, then "key.a" will fetch the value 3 (this works for dictionary entries as well as object attributes)


Site generation.
1. Create a context with meta.json (which contains a dictionary) and macros.py
  - meta.json meta [key: value] pairs will be directly added to the context
  - macros.py is executed. The function [macro(s, fun)] is exposed, where [s] is the name of the context key that will invoke the macro, and [fun] is a lambda expression [lambda: ctx [, params] = ...] that takes in context [ctx] and outputs any stringable value. When the macro is invoked through {{key}}, the lambda expression is called with the current file's context as the parameter. These macros are all added to the context. Ex: macro("example", lambda: ctx = ctx_fetch("site.url")) declares a macro that fetches the site.url property from the context when invoked with {{example}}.
    - ctx_fetch(ctx, key) is also exposed, which allows access of context variables through dot notation. Ex: ctx_fetch(ctx, "site.url").
2. Traverse the site directory and its subdirectories, creating corresponding built files in respective paths in OutputDir.
  - Pipeline: a) File -> b) Local template -> c) Master template
    a) Each file gets turned into a dictionary which is passed to the local template.
      - Each file gets a context with a view of the directory tree, with names in lowercase and with file extensions removed.
        - Directories are represented by dictionaries with key name equal to lowercased directory name
        - Each file in the directory tree has properties is_file = True, path (path of output file [with the extension of the output file], relative to site top), template_path (path of its local template), and date (time struct) which contains the last date modified.

      - .md files become {"content": [html-compiled content], [meta-key-1]: [meta-value-1], ...} where the meta entries come from the Markdown meta section.
      - .md+ files are processed like .md files but are first compiled against themselves.
      - .html+ files become {"content": [c]} where c is the file compiled against itself.
      - .xml+ files are compiled against themselves.
    b) .md, md+, and .html+ files are compiled against the local template, which is the template in the shallowest parent directory of the file that contains a template.tmpl file.
    c) .md, md+, and .html+ files are compiled against the master template.
  - Files with extensions other than .md, .md+, .html+ and .xml+ are simply copied to the output folder.


Context namespace map.
- Top-level directory names
- Entries declared in meta/meta.json and meta/macros.py
- Meta entries if current file is a Markdown file
- "content": contains the content for the current template
- "MetaDir", "OutputDir"


Directory structure.
site/
  [index.html+]
  [archive.html+]
  output/ <- OutputDir
  meta/   <- MetaDir
    master.tmpl
    meta.json
    macros.py
  [pages]/
    template.tmpl
    [Life]/
      [funstuff.md]
    [Work]/
      template.tmpl
      [meetings.md]
  [posts]/
    template.tmpl
    [hello.md+]
    [codesamples.md+]
